#!/usr/bin/python
"""

.. sectionauthor:: Asher Bender <a.bender.dev@gmail.com>
.. codeauthor:: Asher Bender <a.bender.dev@gmail.com>

"""

import os
import sys
import time
import argparse
import datetime
import textwrap
import multiprocessing

from common.common import pong
from common.common import make_payload


if __name__ == '__main__':

    # -------------------------------------------------------------------------
    #         Configure command-line options & parsing behaviour
    # -------------------------------------------------------------------------

    man = """Receive 'ping' messages and issue a 'pong' message.

    Receive 'ping' messages and re-transmit the contents of the message as a
    'pong' message.

    """
    formatter_class = argparse.RawDescriptionHelpFormatter
    parser = argparse.ArgumentParser(formatter_class=formatter_class,
                                     description=textwrap.dedent(man))

    msg = 'Number of broadcasters on network.'
    parser.add_argument('--broadcasters', type=int, help=msg, default=1)

    msg = 'Number of listeners to launch.'
    parser.add_argument('--listeners', type=int, help=msg, default=1)

    msg = 'Force a specific pong ID.'
    parser.add_argument('--ID', type=int, help=msg, default=None)

    msg = 'Time to send pongs.'
    parser.add_argument('--time', type=float, help=msg, default=None)

    choices = ['lcm', 'mcl', 'pyre', 'rabbitmq', 'ros', 'zmq']
    msg = "Underlying transport to use during test. Choose from '%r'."
    parser.add_argument('--transport', choices=choices, default='mcl')

    msg = 'Print  messages to screen.'
    parser.add_argument('--verbose', action='store_true', default=False,
                        help=msg)

    # Get arguments from the command-line.
    args = parser.parse_args()

    # Load transport method.
    if args.transport == 'lcm':
        from common.lcm import SendPong
    elif args.transport == 'mcl':
        from common.mcl import SendPong
    elif args.transport == 'pyre':
        from common.pyre import SendPong
    elif args.transport == 'rabbitmq':
        from common.rabbitmq import SendPong
    elif args.transport == 'ros':
        from common.ros import SendPong
    elif args.transport == 'zmq':
        from common.zmq import SendPong


    # -------------------------------------------------------------------------
    #                         Receive PongMessage()
    # -------------------------------------------------------------------------

    # Create event for controlling execution of processes.
    start_event = multiprocessing.Event()
    pong_queues = [multiprocessing.Queue() for i in range(args.listeners)]
    start_event.clear()

    # Create process for broadcasting PongMessages()
    processes = list()

    # Force a specific ponger ID.
    if args.ID:
        processes.append(multiprocessing.Process(target=pong,
                                                 args=(SendPong, args.ID,
                                                       args.broadcasters,
                                                       start_event,
                                                       pong_queues[0],
                                                       args.transport,
                                                       args.verbose)))

    # Launch a number of 'ponger' listeners.
    else:
        for i in range(args.listeners):
            processes.append(multiprocessing.Process(target=pong,
                                                     args=(SendPong, i,
                                                           args.broadcasters,
                                                           start_event,
                                                           pong_queues[i],
                                                           args.transport,
                                                           args.verbose)))

    # Start the listeners.
    for process in processes:
        process.daemon = True
        process.start()
        time.sleep(0.1)

    # Wait for the user to terminate the process.
    print 'Starting pongs...'
    start_event.set()
    start_time = datetime.datetime.utcnow()
    while True:
        try:
            time.sleep(0.1)

            if (args.time is not None):
                elapsed_time = datetime.datetime.utcnow() - start_time
                if elapsed_time.total_seconds() > args.time:
                    start_event.clear()
                    break

        except KeyboardInterrupt:
            start_event.clear()
            break

    # Allow processes to shut down correctly.
    for i, proc in enumerate(processes):
        pong_queues[i] = pong_queues[i].get()
        proc.join()

    print 'Pongs stopped...'
